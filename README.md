
Алгоритм нахождения самого длинного суффикса, принадлежащего языку.

Пусть s - длина данного на вход регулярного выражения, n - длина слова. Буду называть подстрокой слова alpha от i до j все буквы лежащие между i-ым и j-ым межбуквенным промежутком. Нулевой межбуквенный промежуток расположен перед первой буквой, а последний - после последней.

Алгоритм будет работать индуктивно, постепенно разбирая выражение в польской записи. Для каждого уже обработанного регулярного выражения будем хранить массив M длины n + 1 множеств целых чисел. M[i] содержит все индексы j такие, что подстрока данного слова от i до j принимается обработанным регулярным выражением.

По очереди считываем символы строки, задающей регулярное выражение. Если текущий символ - какая-то буква алфавита или единица, обрабатываем его как регулярное выражение и кладем в стек соответствующий ему массив. Если это + или ., вынимаем из стека два последних выражения, применяем к ним нужную операцию и кладем обратно в стек. Если это *, вынимаем последний элемент из стека, применяем к нему звезду Клини и кладем обратно. Если в какой-то момент нам надо достать элемент из стека, а его там нет, выводим сообщение об ошибке. В конце в стеке окажется один элемент (если не так, тоже выведем сообщение об ошибке). Если каждая из операций работает корректно, в конце останется массив M длины n + 1 и j принадлежит M[i] тогда и только тогда, когда подслово с i по j принимается введенным регулярным выражением. Таким образом, пройдемся по этому массиву слева направо и найдем первый элемент, начиная с которого можно дочитать слово до конца. Вычитая его позицию из общей длины, получим ответ.

Осталось описать операции и доказать их корректность.

1) Ввод единицы

Массив множеств, соответсвующих этому регулярному выражению таков, что M[i] = i.

2) Ввод буквы

Массив множеств, соответсвующих этому регулярному выражению таков, что M[i] = i + 1, если i + 1 \leq n.

3) Сложение

Если M, N - массивы, соответствующие складываемым выражениям, а L - массив для их суммы, то L[i] равняется объединению M[i] и N[i]

4) Конкатенация

Если M, N - массивы, соответствующие складываемым выражениям, а L - массив для их суммы, то j принадлежит L[i], коль скоро 
существует k : k принадлежит M[i], j принадлежит N[k].

5) Звезда Клини

Посмотрим на массив как на граф, записанный в виде списков смежности. После применения операции граф преобразуется в свое транзитивное замыкание. Для этого запустим DFS из каждой вершины и добавим все посещенные вершины.

Осталось оценить асимптотику: будет s итераций разбора выражения, каждая из которых работает за O(n), если это считывание константного символа, O(nlogn) для сложения, O(n^{2}logn для умножения и O(n^{3}logn) для звезды Клини (поскольку запускаем n обходов, каждый максимум по n^2 ребрам). Итого O(sn^3logn). От логарифма можно было бы избавиться, используя вместо множества другую структуру данных.


\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}

% Размер страницы и текста
% margin — поля
\usepackage[a5paper,margin=1cm,bmargin=1.5cm]{geometry}
\usepackage{parskip}

% Пакеты American Mathematical Society
% дает \begin{equation}, \begin{align} и многое другое
\usepackage{amsmath}
% дает много разных математических символов
\usepackage{amssymb}
% дает \newtheorem, а также \begin{proof}
\usepackage{amsthm}

% дает \begin{problem}
\newtheorem{problem}{Задача}

% дает \begin{answer}
\newenvironment{answer}{\par\emph{Ответ:}}{\par}

% дает \begin{solution}; основан на \begin{proof} из amsthm
\newenvironment{solution}[1][Решение]{\vspace{-\parskip}\begin{proof}[#1]}{\end{proof}}

\begin{document}

\title{Алгоритм нахождения самого длинного суффикса, принадлежащего языку.}

\date{Формальные языки и трансляции, МФТИ 2021}

\maketitle

Пусть $s$ - длина данного на вход регулярного выражения, $n$ - длина слова. Буду называть подстрокой слова $\alpha$ от $i$ до $j$ все буквы лежащие между $i$-ым и $j$-ым межбуквенным промежутком. Нулевой межбуквенный промежуток расположен перед первой буквой, а последний - после последней.

Алгоритм будет работать индуктивно, постепенно разбирая выражение в польской записи. Для каждого уже обработанного регулярного выражения будем хранить массив $M$ длины $n + 1$ множеств целых чисел. $M[i]$ содержит все индексы $j$ такие, что подстрока данного слова от $i до j$ принимается обработанным регулярным выражением.

По очереди считываем символы строки, задающей регулярное выражение. Если текущий символ - какая-то буква алфавита или единица, обрабатываем его как регулярное выражение и кладем в стек соответствующий ему массив. Если это $+$ или $.$, вынимаем из стека два последних выражения, применяем к ним нужную операцию и кладем обратно в стек. Если это $*$, вынимаем последний элемент из стека, применяем к нему звезду Клини и кладем обратно. Если в какой-то момент нам надо достать элемент из стека, а его там нет, выводим сообщение об ошибке. В конце в стеке окажется один элемент (если не так, тоже выведем сообщение об ошибке). Если каждая из операций работает корректно, в конце останется массив $M$ длины $n + 1$ и $j \in M[i]$ тогда и только тогда, когда подслово с $i$ по $j$ принимается введенным регулярным выражением. Таким образом, пройдемся по этому массиву слева направо и найдем первый элемент, начиная с которого можно дочитать слово до конца. Вычитая его позицию из общей длины, получим ответ.

Осталось описать операции и доказать их корректность.

1) Ввод единицы

Массив множеств, соответсвующих этому регулярному выражению таков, что $M[i] = i$.

2) Ввод буквы

Массив множеств, соответсвующих этому регулярному выражению таков, что $M[i] = i + 1$, если $i + 1 \leq n$.

3) Сложение

Если $M, N$ - массивы, соответствующие складываемым выражениям, а $L$ - массив для их суммы, то $L[i] = M[i] \cup N[i]$

4) Конкатенация

Если $M, N$ - массивы, соответствующие складываемым выражениям, а $L$ - массив для их суммы, то $j \in L[i]$, коль скоро 
$\exists k : k \in M[i], j \in N[k]$.

5) Звезда Клини

Посмотрим на массив как на граф, записанный в виде списков смежности. После применения операции граф преобразуется в свое транзитивное замыкание. Для этого запустим DFS из каждой вершины и добавим все посещенные вершины.

Осталось оценить асимптотику: будет $s$ итераций разбора выражения, каждая из которых работает за $O(n)$, если это считывание константного символа, $O(nlogn)$ для сложения, $O(n^{2}logn$ для умножения и $O(n^{3}logn$ для звезды Клини (поскольку запускаем $n$ обходов, каждый максимум по $n^2$ ребрам). Итого $O(sn^3logn)$. От логарифма можно было бы избавиться, используя вместо множества другую структуру данных.
\end{document}
